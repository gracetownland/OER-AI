"""
Response cache manager for practice material generation.

Uses DynamoDB for persistent caching with TTL expiration
to reduce LLM API calls for repeated requests.
"""

import os
import time
import hashlib
import logging
import re
import json
from typing import Any, Dict
from decimal import Decimal

import boto3
from botocore.exceptions import ClientError

logger = logging.getLogger(__name__)

# Cache configuration
CACHE_TTL_DAYS = 7
CACHE_TTL_SECONDS = CACHE_TTL_DAYS * 24 * 60 * 60

# DynamoDB client - initialized lazily
_dynamodb_table = None


def _get_cache_table():
    """Get or initialize the DynamoDB cache table."""
    global _dynamodb_table
    
    if _dynamodb_table is None:
        table_name = os.environ.get("CACHE_TABLE_NAME")
        if not table_name:
            logger.warning("CACHE_TABLE_NAME not set, caching disabled")
            return None
        
        dynamodb = boto3.resource("dynamodb")
        _dynamodb_table = dynamodb.Table(table_name)
        logger.info(f"Initialized DynamoDB cache table: {table_name}")
    
    return _dynamodb_table


def normalize_topic(topic: str) -> str:
    """
    Normalize topic string for consistent cache key generation.
    
    Performs:
    - Lowercase conversion
    - Strip leading/trailing whitespace
    - Collapse multiple spaces to single space
    - Remove punctuation except hyphens
    
    Args:
        topic: Raw topic string from user
    
    Returns:
        Normalized topic string
    """
    if not topic:
        return ""
    
    # Lowercase and strip
    normalized = topic.lower().strip()
    
    # Remove punctuation except hyphens (keep "DNA-replication" as-is)
    normalized = re.sub(r'[^\w\s-]', '', normalized)
    
    # Collapse multiple spaces to single space
    normalized = re.sub(r'\s+', ' ', normalized)
    
    return normalized


def generate_cache_key(
    textbook_id: str,
    topic: str,
    material_type: str,
    difficulty: str,
    num_items: int,
    extra_params: str = ""
) -> str:
    """
    Generate a consistent cache key for practice material requests.
    
    Topic is normalized before hashing for better cache hit rates.
    
    Args:
        textbook_id: UUID of the textbook
        topic: User-provided topic (will be normalized)
        material_type: Type of material ('mcq', 'flashcard', 'short_answer')
        difficulty: Difficulty level
        num_items: Number of questions/cards
        extra_params: Additional parameters (e.g., num_options, card_type)
    
    Returns:
        MD5 hash of the normalized request parameters
    """
    normalized_topic = normalize_topic(topic)
    cache_string = f"{textbook_id}:{normalized_topic}:{material_type}:{difficulty}:{num_items}:{extra_params}"
    return hashlib.md5(cache_string.encode()).hexdigest()


def _convert_decimals(obj):
    """Convert Decimal objects to int/float for JSON serialization."""
    if isinstance(obj, Decimal):
        if obj % 1 == 0:
            return int(obj)
        return float(obj)
    elif isinstance(obj, dict):
        return {k: _convert_decimals(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [_convert_decimals(i) for i in obj]
    return obj


def get_cached_response(cache_key: str) -> Dict[str, Any] | None:
    """
    Retrieve cached response from DynamoDB if available and not expired.
    
    Args:
        cache_key: Cache key generated by generate_cache_key
    
    Returns:
        Cached response dict or None if not found/expired
    """
    table = _get_cache_table()
    if table is None:
        return None
    
    try:
        response = table.get_item(Key={"cache_key": cache_key})
        
        if "Item" not in response:
            logger.debug(f"Cache MISS for key: {cache_key}")
            return None
        
        item = response["Item"]
        
        # Check if expired (TTL is handled by DynamoDB, but double-check)
        expires_at = item.get("expires_at", 0)
        if time.time() > expires_at:
            logger.info(f"Cache entry expired for key: {cache_key}")
            return None
        
        logger.info(f"Cache HIT for key: {cache_key}")
        
        # Convert DynamoDB Decimal types and parse JSON
        result_json = item.get("result", "{}")
        sources_json = item.get("sources", "[]")
        
        return {
            "result": json.loads(result_json) if isinstance(result_json, str) else _convert_decimals(result_json),
            "sources": json.loads(sources_json) if isinstance(sources_json, str) else _convert_decimals(sources_json),
            "timestamp": _convert_decimals(item.get("timestamp", 0))
        }
        
    except ClientError as e:
        logger.error(f"DynamoDB error getting cache: {e}")
        return None
    except Exception as e:
        logger.error(f"Error getting cached response: {e}")
        return None


def set_cached_response(
    cache_key: str,
    result: Dict[str, Any],
    sources: list[str]
) -> None:
    """
    Store response in DynamoDB cache with TTL.
    
    Args:
        cache_key: Cache key generated by generate_cache_key
        result: Generated practice material result
        sources: List of source citations
    """
    table = _get_cache_table()
    if table is None:
        return
    
    try:
        current_time = int(time.time())
        expires_at = current_time + CACHE_TTL_SECONDS
        
        item = {
            "cache_key": cache_key,
            "result": json.dumps(result),
            "sources": json.dumps(sources),
            "timestamp": current_time,
            "expires_at": expires_at,
        }
        
        table.put_item(Item=item)
        logger.info(f"Cache SET for key: {cache_key} (expires in {CACHE_TTL_DAYS} days)")
        
    except ClientError as e:
        logger.error(f"DynamoDB error setting cache: {e}")
    except Exception as e:
        logger.error(f"Error setting cached response: {e}")


def get_cache_stats() -> Dict[str, Any]:
    """
    Get current cache configuration.
    
    Returns:
        Dictionary with cache TTL settings
    """
    table = _get_cache_table()
    return {
        "type": "dynamodb",
        "table_name": table.table_name if table else None,
        "ttl_days": CACHE_TTL_DAYS,
        "ttl_seconds": CACHE_TTL_SECONDS,
        "enabled": table is not None
    }


def clear_cache() -> None:
    """
    Clear all cached responses.
    
    Note: This is expensive for DynamoDB - use sparingly.
    For production, consider using TTL-based expiration instead.
    """
    table = _get_cache_table()
    if table is None:
        return
    
    try:
        total_deleted = 0
        
        # Scan with pagination - DynamoDB returns max 1MB per scan
        scan_kwargs = {"ProjectionExpression": "cache_key"}
        
        while True:
            scan = table.scan(**scan_kwargs)
            items = scan.get("Items", [])
            
            with table.batch_writer() as batch:
                for item in items:
                    batch.delete_item(Key={"cache_key": item["cache_key"]})
            
            total_deleted += len(items)
            
            # Check if there are more items to scan
            if "LastEvaluatedKey" in scan:
                scan_kwargs["ExclusiveStartKey"] = scan["LastEvaluatedKey"]
            else:
                break
        
        logger.info(f"Cache cleared: {total_deleted} items deleted")
        
    except Exception as e:
        logger.error(f"Error clearing cache: {e}")
